extern const string VERSION;

private HashTable<string, EnumDescriptorProto> enums;

public static int main (string[] args)
{
    var data = new uint8[0];
    while (true)
    {
        uint8 buffer[65535];
        var n_read = stdin.read (buffer);
    if (n_read < 0)
            return Posix.EXIT_FAILURE;
        if (n_read == 0)
            break;

        var n_used = data.length;
        data.resize (n_used + (int) n_read);
        for (var i = 0; i < n_read; i++)
            data[n_used + i] = buffer[i];
    }

    var buf = new Protobuf.DecodeBuffer (data);
    var req = new CodeGeneratorRequest ();
    req.decode (buf);

    //stderr.printf ("request = {\n%s}\n", req.to_string ("  "));

    var resp = new CodeGeneratorResponse ();
    resp.supported_features = (uint64) CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL;

    enums = new HashTable<string, EnumDescriptorProto> (str_hash, str_equal);
    foreach (var f in req.proto_file)
        collect_types (f);
    foreach (var f in req.proto_file)
    {
        var out_file = new CodeGeneratorResponse.File ();

        if (f.name.has_suffix (".proto"))
            out_file.name = f.name.substring (0, f.name.length - 6) + ".pb.vala";
        else
            out_file.name = f.name + ".vala";
    
        /* Generate valid namespace */
        var vala_namespace = "";
        if (f.package != "")
            vala_namespace = get_namespace (f.package);

        out_file.content = "// Generated by protoc-gen-vala %s from %s, do not edit\n".printf (VERSION, f.name);
        var is_proto3 = f.syntax == "proto3";
        if (vala_namespace != "")
        {
            out_file.content += "\n";
            out_file.content += "namespace %s {\n".printf (vala_namespace);
        }
        foreach (var enum_type in f.enum_type)
        {
            out_file.content += "\n";
            out_file.content += write_enum (enum_type);
        }
        foreach (var message_type in f.message_type)
        {
            out_file.content += "\n";
            out_file.content += write_class (message_type, is_proto3);
        }
        if (vala_namespace != "")
        {
            out_file.content += "\n";
            out_file.content += "}\n";
        }        

        resp.file.append (out_file);
    }

    var resp_buf = new Protobuf.EncodeBuffer ();
    resp.encode (resp_buf);

    stdout.write (resp_buf.data);
    stdout.flush ();

    return 0;
}

private static string join_name (string prefix, string name)
{
    if (prefix == "")
        return name;
    return "%s.%s".printf (prefix, name);
}

private static string qualify_name (string prefix, string name)
{
    var full = join_name (prefix, name);
    return ".%s".printf (full);
}

private static void collect_types (FileDescriptorProto f)
{
    var prefix = f.package;
    foreach (var enum_type in f.enum_type)
        enums.insert (qualify_name (prefix, enum_type.name), enum_type);
    foreach (var message_type in f.message_type)
        collect_message_types (message_type, prefix);
}

private static void collect_message_types (DescriptorProto type, string prefix)
{
    var full = join_name (prefix, type.name);
    foreach (var enum_type in type.enum_type)
        enums.insert (qualify_name (full, enum_type.name), enum_type);
    foreach (var nested_type in type.nested_type)
        collect_message_types (nested_type, full);
}

private static string write_enum (EnumDescriptorProto type, string indent = "")
{
    var text = "";

    text += indent + "public enum %s\n".printf (type.name);
    text += indent + "{\n";
    foreach (var value in type.value)
        text += indent + "    %s = %d,\n".printf (value.name, value.number);
    text += indent + "}\n";
    text += indent + "public static string %s_to_string (%s value)\n".printf (type.name, type.name);
    text += indent + "{\n";
    text += indent + "    switch (value)\n";
    text += indent + "    {\n";
    foreach (var value in type.value)
    {
        text += indent + "    case %s.%s:\n".printf (type.name, value.name);
        text += indent + "        return \"%s\";\n".printf (value.name);
    }
    text += indent + "    default:\n";
    text += indent + "        return \"%d\".printf (value);\n";
    text += indent + "    }\n";
    text += indent + "}\n";

    return text;
}

private static string write_class (DescriptorProto type, bool is_proto3, string indent = "")
{
    var text = "";
    var oneof_count = (int) type.oneof_decl.length ();
    bool[] oneof_real = new bool[oneof_count];
    string[] oneof_names = new string[oneof_count];
    for (var i = 0; i < oneof_count; i++)
        oneof_names[i] = type.oneof_decl.nth_data (i).name;
    foreach (var field in type.field)
    {
        if (field.has_oneof_index && field.oneof_index >= 0 && field.oneof_index < oneof_count && !field.proto3_optional)
            oneof_real[field.oneof_index] = true;
    }
    string[] oneof_enum_names = new string[oneof_count];
    string[] oneof_case_vars = new string[oneof_count];
    for (var i = 0; i < oneof_count; i++)
    {
        if (!oneof_real[i])
            continue;
        oneof_enum_names[i] = sanitize_identifier (camel_case (oneof_names[i]) + "Case");
        oneof_case_vars[i] = sanitize_identifier (oneof_names[i] + "_case");
    }
    text += indent + "public class %s : Protobuf.Message\n".printf (type.name);
    text += indent + "{\n";
    foreach (var enum_type in type.enum_type)
        text += write_enum (enum_type, indent + "    ");
    foreach (var nested_type in type.nested_type)
        text += write_class (nested_type, is_proto3, indent + "    ");
    for (var i = 0; i < oneof_count; i++)
    {
        if (!oneof_real[i])
            continue;
        text += indent + "    public enum %s\n".printf (oneof_enum_names[i]);
        text += indent + "    {\n";
        text += indent + "        NONE = 0,\n";
        foreach (var field in type.field)
        {
            if (!field.has_oneof_index || field.oneof_index != i || field.proto3_optional)
                continue;
            text += indent + "        %s = %d,\n".printf (oneof_case_value_name (field), field.number);
        }
        text += indent + "    }\n";
    }
    for (var i = 0; i < oneof_count; i++)
    {
        if (!oneof_real[i])
            continue;
        text += indent + "    public %s %s;\n".printf (oneof_enum_names[i], oneof_case_vars[i]);
    }
    foreach (var field in type.field)
        text += indent + "    public %s %s;\n".printf (get_type_name (field, true, is_proto3), get_field_name (field));
    text += "\n";
    text += indent + "    public %s ()\n".printf (type.name);
    text += indent + "    {\n";
    foreach (var field in type.field)
        text += indent + "        this.%s = %s;\n".printf (get_field_name (field), get_default_value (field, is_proto3));
    for (var i = 0; i < oneof_count; i++)
    {
        if (!oneof_real[i])
            continue;
        text += indent + "        this.%s = %s.NONE;\n".printf (oneof_case_vars[i], oneof_enum_names[i]);
    }
    text += indent + "    }\n";
    text += "\n";    
    for (var i = 0; i < oneof_count; i++)
    {
        if (!oneof_real[i])
            continue;
        var clear_method = sanitize_identifier ("clear_" + oneof_names[i]);
        text += indent + "    public void %s ()\n".printf (clear_method);
        text += indent + "    {\n";
        foreach (var field in type.field)
        {
            if (!field.has_oneof_index || field.oneof_index != i || field.proto3_optional)
                continue;
            text += indent + "        this.%s = %s;\n".printf (get_field_name (field), get_default_value (field, is_proto3));
        }
        text += indent + "        this.%s = %s.NONE;\n".printf (oneof_case_vars[i], oneof_enum_names[i]);
        text += indent + "    }\n";
        text += "\n";
        foreach (var field in type.field)
        {
            if (!field.has_oneof_index || field.oneof_index != i || field.proto3_optional)
                continue;
            var set_method = sanitize_identifier ("set_" + field.name);
            text += indent + "    public void %s (%s value)\n".printf (set_method, get_type_name (field, false, is_proto3));
            text += indent + "    {\n";
            text += indent + "        %s ();\n".printf (clear_method);
            text += indent + "        this.%s = value;\n".printf (get_field_name (field));
            text += indent + "        this.%s = %s.%s;\n".printf (oneof_case_vars[i], oneof_enum_names[i], oneof_case_value_name (field));
            text += indent + "    }\n";
            text += "\n";
        }
    }
    text += indent + "    public %s.from_data (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)\n".printf (type.name);
    text += indent + "    {\n";
    text += indent + "        decode (buffer, data_length);\n";
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public override bool decode (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)\n";
    text += indent + "    {\n";
    text += indent + "        size_t end;\n";
    text += indent + "        if (data_length < 0)\n";
    text += indent + "            end = buffer.buffer.length;\n";
    text += indent + "        else\n";
    text += indent + "            end = buffer.read_index + data_length;\n";
    var required_field_check = "";
    if (!is_proto3)
    {
        foreach (var field in type.field)
        {
            if (field.label != FieldDescriptorProto.Label.LABEL_REQUIRED)
                continue;
            text += indent + "        var have_%s = false;\n".printf (field.name);
            if (required_field_check != "")
                required_field_check += " || ";
            required_field_check += "!have_%s".printf (field.name);
        }
    }
    text += "\n";
    foreach (var field in type.field)
        text += indent + "        this.%s = %s;\n".printf (get_field_name (field), get_default_value (field, is_proto3));
    for (var i = 0; i < oneof_count; i++)
    {
        if (!oneof_real[i])
            continue;
        text += indent + "        this.%s = %s.NONE;\n".printf (oneof_case_vars[i], oneof_enum_names[i]);
    }
    text += indent + "        while (buffer.read_index < end)\n";
    text += indent + "        {\n";
    text += indent + "            var key = buffer.decode_varint ();\n";
    text += indent + "            var wire_type = key & 0x7;\n";
    text += indent + "            var field_number = key >> 3;\n";
    text += "\n";
    var first = true;
    foreach (var field in type.field)
    {
        var decode_method = "";
        var base_wire_type = 0;
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_DOUBLE:
            base_wire_type = 1;
            decode_method = "buffer.decode_double ()";
            break;
        case FieldDescriptorProto.Type.TYPE_FLOAT:
            base_wire_type = 5;
            decode_method = "buffer.decode_float ()";
            break;
        case FieldDescriptorProto.Type.TYPE_INT64:
            base_wire_type = 0;
            decode_method = "buffer.decode_int64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_UINT64:
            base_wire_type = 0;
            decode_method = "buffer.decode_uint64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_INT32:
            base_wire_type = 0;
            decode_method = "buffer.decode_int32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED64:
            base_wire_type = 1;
            decode_method = "buffer.decode_fixed64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED32:
            base_wire_type = 5;
            decode_method = "buffer.decode_fixed32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_BOOL:
            base_wire_type = 0;
            decode_method = "buffer.decode_bool ()";
            break;
        case FieldDescriptorProto.Type.TYPE_STRING:
            base_wire_type = 2;
            decode_method = "buffer.decode_string ((size_t) buffer.decode_varint ())";
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            base_wire_type = 2;
            decode_method = "buffer.decode_bytes ((size_t) buffer.decode_varint ())";
            break;
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            base_wire_type = 2;
            decode_method = "new %s.from_data (buffer, (ssize_t) buffer.decode_varint ())".printf (get_type_name (field, false, is_proto3));
            break;
        case FieldDescriptorProto.Type.TYPE_ENUM:
            base_wire_type = 0;
            decode_method = "(%s) buffer.decode_varint ()".printf (get_type_name (field, false, is_proto3));
            break;
        case FieldDescriptorProto.Type.TYPE_UINT32:
            base_wire_type = 0;
            decode_method = "buffer.decode_uint32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED32:
            base_wire_type = 5;
            decode_method = "buffer.decode_sfixed32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED64:
            base_wire_type = 1;
            decode_method = "buffer.decode_sfixed64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SINT32:
            base_wire_type = 0;
            decode_method = "buffer.decode_sint32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SINT64:
            base_wire_type = 0;
            decode_method = "buffer.decode_sint64 ()";
            break;
        default:
            // FIXME: Exit with error
            decode_method = "buffer.DECODE_UNKNOWN_TYPE%d ()".printf (field.type);
            break;
        }

        var packed = is_packed (field, is_proto3);
        if (!is_packable (field))
            packed = false;
        var in_real_oneof = field.has_oneof_index && field.oneof_index >= 0 && field.oneof_index < oneof_count && oneof_real[field.oneof_index] && !field.proto3_optional;
        var oneof_index = field.oneof_index;
        if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED && packed)
        {
            text += indent + "            %s (field_number == %d && wire_type == 2)\n".printf (first ? "if" : "else if", field.number);
            text += indent + "            {\n";
            text += indent + "                var %s_length = buffer.decode_varint ();\n".printf (field.name);
            text += indent + "                var %s_end = buffer.read_index + %s_length;\n".printf (field.name, field.name);
            text += indent + "                while (buffer.read_index < %s_end)\n".printf (field.name);
            text += indent + "                    this.%s.append (%s);\n".printf (get_field_name (field), decode_method);
            text += indent + "                if (buffer.read_index != %s_end)\n".printf (field.name);
            text += indent + "                    buffer.error = true;\n";
            text += indent + "            }\n";
            text += indent + "            else if (field_number == %d && wire_type == %d)\n".printf (field.number, base_wire_type);
            text += indent + "                this.%s.append (%s);\n".printf (get_field_name (field), decode_method);
        }
        else
        {
            text += indent + "            %s (field_number == %d && wire_type == %d)\n".printf (first ? "if" : "else if", field.number, base_wire_type);
            if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            {
                text += indent + "                this.%s.append (%s);\n".printf (get_field_name (field), decode_method);
            }
            else if (in_real_oneof)
            {
                text += indent + "            {\n";
                text += indent + "                %s ();\n".printf (sanitize_identifier ("clear_" + oneof_names[oneof_index]));
                text += indent + "                this.%s = %s;\n".printf (get_field_name (field), decode_method);
                text += indent + "                this.%s = %s.%s;\n".printf (oneof_case_vars[oneof_index], oneof_enum_names[oneof_index], oneof_case_value_name (field));
                text += indent + "            }\n";
            }
            else if (field.label == FieldDescriptorProto.Label.LABEL_REQUIRED)
            {
                text += indent + "            {\n";
                text += indent + "                this.%s = %s;\n".printf (get_field_name (field), decode_method);
                text += indent + "                have_%s = true;\n".printf (field.name);
                text += indent + "            }\n";
            }
            else
                text += indent + "                this.%s = %s;\n".printf (get_field_name (field), decode_method);
        }

        first = false;
    }
    if (type.field.length () > 0)
    {
        text += indent + "            else\n   ";
    }
    text += indent + "            this.unknown_fields.prepend (buffer.decode_unknown_field (key));\n";
    text += indent + "        }\n";
    text += "\n";
    text += indent + "        if (buffer.read_index != end)\n";
    text += indent + "            buffer.error = true;\n";
    if (required_field_check != "")
    {
        text += indent + "        else if (%s)\n".printf (required_field_check);
        text += indent + "            buffer.error = true;\n";
    }
    text += "\n";
    text += indent + "        return !buffer.error;\n";
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public override size_t encode (Protobuf.EncodeBuffer buffer)\n";
    text += indent + "    {\n";
    text += indent + "        size_t n_written = 0;\n";
    text += "\n";
    text += indent + "        foreach (var f in this.unknown_fields)\n";
    text += indent + "            n_written += buffer.encode_unknown_field (f);\n";
    for (unowned List<FieldDescriptorProto> i = type.field.last (); i != null; i = i.prev)
    {
        var field = i.data;
        var in_real_oneof = field.has_oneof_index && field.oneof_index >= 0 && field.oneof_index < oneof_count && oneof_real[field.oneof_index] && !field.proto3_optional;
        if (in_real_oneof)
            continue;
        var packed = is_packed (field, is_proto3);
        if (!is_packable (field))
            packed = false;
        var indent2 = indent;
        var field_name = "this.%s".printf (get_field_name (field));
        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL)
        {
            text += indent + "        if (%s != %s)\n".printf (field_name, get_default_value (field, is_proto3));
            text += indent + "        {\n";
            indent2 += "    ";
        }
        else if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            if (packed)
                text += indent + "        size_t %s_length = 0;\n".printf (field.name);
            text += indent + "        for (unowned %s i = %s.last (); i != null; i = i.prev)\n".printf (get_type_name (field, true, is_proto3), field_name);
            text += indent + "        {\n";
            indent2 += "    ";
            field_name = "i.data";
        }

        var encode_length = false;
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_STRING:
        case FieldDescriptorProto.Type.TYPE_BYTES:
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            encode_length = true;
            break;
        }

        text += indent2 + "        ";
        if (encode_length)
            text += "var %s_length = ".printf (field.name);
        else if (packed)
            text += "%s_length += ".printf (field.name);
        else
            text += "n_written += ";
        var wire_type = 0;
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_DOUBLE:
            text += "buffer.encode_double (%s);\n".printf (field_name);
            wire_type = 1;
            break;
        case FieldDescriptorProto.Type.TYPE_FLOAT:
            text += "buffer.encode_float (%s);\n".printf (field_name);
            wire_type = 5;
            break;
        case FieldDescriptorProto.Type.TYPE_INT64:
            text += "buffer.encode_int64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_UINT64:
            text += "buffer.encode_uint64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_INT32:
            text += "buffer.encode_int32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED64:
            text += "buffer.encode_fixed64 (%s);\n".printf (field_name);
            wire_type = 1;
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED32:
            text += "buffer.encode_fixed32 (%s);\n".printf (field_name);
            wire_type = 5;
            break;
        case FieldDescriptorProto.Type.TYPE_BOOL:
            text += "buffer.encode_bool (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_STRING:
            text += "buffer.encode_string (%s);\n".printf (field_name);
            wire_type = 2;
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            text += "buffer.encode_bytes (%s);\n".printf (field_name);
            wire_type = 2;
            break;
        case FieldDescriptorProto.Type.TYPE_UINT32:
            text += "buffer.encode_uint32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED64:
            text += "buffer.encode_sfixed64 (%s);\n".printf (field_name);
            wire_type = 1;
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED32:
            text += "buffer.encode_sfixed32 (%s);\n".printf (field_name);
            wire_type = 5;
            break;
        case FieldDescriptorProto.Type.TYPE_SINT64:
            text += "buffer.encode_sint64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SINT32:
            text += "buffer.encode_sint32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            text += "%s.encode (buffer);\n".printf (field_name);
            wire_type = 2;
            break;
        case FieldDescriptorProto.Type.TYPE_ENUM:
            text += "buffer.encode_varint (%s);\n".printf (field_name);
            break;
        default:
            text += "ENCODE_UNKNOWN_TYPE%d (%s);\n".printf (field.type, field_name);
            break;
        }
        if (encode_length)
        {
            text += indent2 + "        n_written += %s_length;\n".printf (field.name);
            text += indent2 + "        n_written += buffer.encode_varint (%s_length);\n".printf (field.name);
        }

        /* Encode key */
        if (!packed)
        {
            var n = (field.number << 3) | wire_type;
            text += indent2 + "        n_written += buffer.encode_varint (%d);\n".printf (n);
        }

        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL || field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            text += indent + "        }\n";

        if (packed)
        {
            var n = (field.number << 3) | 2;
            text += indent2 + "    if (%s_length != 0)\n".printf (field.name);
            text += indent2 + "    {\n";
            text += indent2 + "        n_written += %s_length;\n".printf (field.name);
            text += indent2 + "        n_written += buffer.encode_varint (%s_length);\n".printf (field.name);
            text += indent2 + "        n_written += buffer.encode_varint (%d);\n".printf (n);
            text += indent2 + "    }\n";
        }
    }
    for (var i = 0; i < oneof_count; i++)
    {
        if (!oneof_real[i])
            continue;
        text += indent + "        switch (this.%s)\n".printf (oneof_case_vars[i]);
        text += indent + "        {\n";
        foreach (var field in type.field)
        {
            if (!field.has_oneof_index || field.oneof_index != i || field.proto3_optional)
                continue;
            var field_name = "this.%s".printf (get_field_name (field));
            var encode_length = false;
            switch (field.type)
            {
            case FieldDescriptorProto.Type.TYPE_STRING:
            case FieldDescriptorProto.Type.TYPE_BYTES:
            case FieldDescriptorProto.Type.TYPE_MESSAGE:
                encode_length = true;
                break;
            }
            text += indent + "        case %s.%s:\n".printf (oneof_enum_names[i], oneof_case_value_name (field));
            text += indent + "        {\n";
            text += indent + "            ";
            if (encode_length)
                text += "var %s_length = ".printf (field.name);
            else
                text += "n_written += ";
            var wire_type = 0;
            switch (field.type)
            {
            case FieldDescriptorProto.Type.TYPE_DOUBLE:
                text += "buffer.encode_double (%s);\n".printf (field_name);
                wire_type = 1;
                break;
            case FieldDescriptorProto.Type.TYPE_FLOAT:
                text += "buffer.encode_float (%s);\n".printf (field_name);
                wire_type = 5;
                break;
            case FieldDescriptorProto.Type.TYPE_INT64:
                text += "buffer.encode_int64 (%s);\n".printf (field_name);
                break;
            case FieldDescriptorProto.Type.TYPE_UINT64:
                text += "buffer.encode_uint64 (%s);\n".printf (field_name);
                break;
            case FieldDescriptorProto.Type.TYPE_INT32:
                text += "buffer.encode_int32 (%s);\n".printf (field_name);
                break;
            case FieldDescriptorProto.Type.TYPE_FIXED64:
                text += "buffer.encode_fixed64 (%s);\n".printf (field_name);
                wire_type = 1;
                break;
            case FieldDescriptorProto.Type.TYPE_FIXED32:
                text += "buffer.encode_fixed32 (%s);\n".printf (field_name);
                wire_type = 5;
                break;
            case FieldDescriptorProto.Type.TYPE_BOOL:
                text += "buffer.encode_bool (%s);\n".printf (field_name);
                break;
            case FieldDescriptorProto.Type.TYPE_STRING:
                text += "buffer.encode_string (%s);\n".printf (field_name);
                wire_type = 2;
                break;
            case FieldDescriptorProto.Type.TYPE_BYTES:
                text += "buffer.encode_bytes (%s);\n".printf (field_name);
                wire_type = 2;
                break;
            case FieldDescriptorProto.Type.TYPE_UINT32:
                text += "buffer.encode_uint32 (%s);\n".printf (field_name);
                break;
            case FieldDescriptorProto.Type.TYPE_SFIXED64:
                text += "buffer.encode_sfixed64 (%s);\n".printf (field_name);
                wire_type = 1;
                break;
            case FieldDescriptorProto.Type.TYPE_SFIXED32:
                text += "buffer.encode_sfixed32 (%s);\n".printf (field_name);
                wire_type = 5;
                break;
            case FieldDescriptorProto.Type.TYPE_SINT64:
                text += "buffer.encode_sint64 (%s);\n".printf (field_name);
                break;
            case FieldDescriptorProto.Type.TYPE_SINT32:
                text += "buffer.encode_sint32 (%s);\n".printf (field_name);
                break;
            case FieldDescriptorProto.Type.TYPE_MESSAGE:
                text += "%s.encode (buffer);\n".printf (field_name);
                wire_type = 2;
                break;
            case FieldDescriptorProto.Type.TYPE_ENUM:
                text += "buffer.encode_varint (%s);\n".printf (field_name);
                break;
            default:
                text += "ENCODE_UNKNOWN_TYPE%d (%s);\n".printf (field.type, field_name);
                break;
            }
            if (encode_length)
            {
                text += indent + "            n_written += %s_length;\n".printf (field.name);
                text += indent + "            n_written += buffer.encode_varint (%s_length);\n".printf (field.name);
            }
            var n = (field.number << 3) | wire_type;
            text += indent + "            n_written += buffer.encode_varint (%d);\n".printf (n);
            text += indent + "            break;\n";
            text += indent + "        }\n";
        }
        text += indent + "        default:\n";
        text += indent + "            break;\n";
        text += indent + "        }\n";
    }
    text += "\n";
    text += indent + "        return n_written;\n";
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public override string to_string (string indent = \"\")\n";
    text += indent + "    {\n";
    text += indent + "        var text = \"\";\n";
    text += "\n";
    foreach (var field in type.field)
    {
        var field_name = "this.%s".printf (get_field_name (field));
        var indent2 = indent;
        var close_blocks = 0;
        var in_real_oneof = field.has_oneof_index && field.oneof_index >= 0 && field.oneof_index < oneof_count && oneof_real[field.oneof_index] && !field.proto3_optional;
        if (in_real_oneof)
        {
            text += indent + "        if (this.%s == %s.%s)\n".printf (oneof_case_vars[field.oneof_index], oneof_enum_names[field.oneof_index], oneof_case_value_name (field));
            text += indent + "        {\n";
            indent2 += "    ";
            close_blocks++;
        }
        if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            text += indent2 + "        foreach (unowned %s v in %s)\n".printf (get_type_name (field, false, is_proto3), field_name);
            text += indent2 + "        {\n";
            indent2 += "    ";
            close_blocks++;
            field_name = "v";
        }
        else if (field.type == FieldDescriptorProto.Type.TYPE_MESSAGE)
        {
            text += indent2 + "        if (%s != null)\n".printf (field_name);
            text += indent2 + "        {\n";
            indent2 += "    ";
            close_blocks++;
        }
        else if (is_nullable_field (field, is_proto3))
        {
            text += indent2 + "        if (%s != null)\n".printf (field_name);
            text += indent2 + "        {\n";
            indent2 += "    ";
            close_blocks++;
        }

        if (field.type == FieldDescriptorProto.Type.TYPE_MESSAGE)
        {
            text += indent2 + "        text += indent + \"%s {\\n\";\n".printf (field.name);
            text += indent2 + "        text += \"%%s\".printf (%s);\n".printf (get_to_string_method (field, field_name, "  ", is_proto3));
            text += indent2 + "        text += indent + \"}\\n\";\n";
        }
        else
            text += indent2 + "        text += indent + \"%s: %%s\\n\".printf (%s);\n".printf (field.name, get_to_string_method (field, field_name, "", is_proto3));

        for (var i = 0; i < close_blocks; i++)
            text += indent + "        }\n";
    }
    text += "\n";
    text += indent + "        return text;\n";
    text += indent + "    }\n";
    text += indent + "}\n";

    return text;
}

private static string get_namespace (string package)
{
    int index = 0;
    unichar c;
    var ns = new StringBuilder.sized (package.length);
    var section_start = true;
    while (package.get_next_char (ref index, out c))
    {
        if (section_start)
        {
            /* Ignore leading '.' */
            if (c == '.')
                continue;

            c = c.toupper ();
            section_start = false;
        }
        ns.append_unichar (c);
        if (c == '.')
            section_start = true;
    }

    return ns.str;
}

private static string get_type_name (FieldDescriptorProto field, bool full = true, bool is_proto3 = false)
{
    var type_name = "";
    var needs_box = false;
    var nullable = false;
    switch (field.type)
    {
    case FieldDescriptorProto.Type.TYPE_DOUBLE:
        type_name = "double";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_FLOAT:
        type_name = "float";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_INT64:
        type_name = "int64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_UINT64:
        type_name = "uint64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_INT32:
        type_name = "int32";
        break;
    case FieldDescriptorProto.Type.TYPE_FIXED64:
        type_name = "uint64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_FIXED32:
        type_name = "uint32";
        break;
    case FieldDescriptorProto.Type.TYPE_BOOL:
        type_name = "bool";
        break;
    case FieldDescriptorProto.Type.TYPE_STRING:
        type_name = "string";
        break;
    case FieldDescriptorProto.Type.TYPE_BYTES:
        type_name = "GLib.ByteArray";
        break;
    case FieldDescriptorProto.Type.TYPE_UINT32:
        type_name = "uint32";
        break;
    case FieldDescriptorProto.Type.TYPE_SFIXED32:
        type_name = "int32";
        break;
    case FieldDescriptorProto.Type.TYPE_SFIXED64:
        type_name = "int64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_SINT32:
        type_name = "int32";
        break;
    case FieldDescriptorProto.Type.TYPE_SINT64:
        type_name = "int64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_MESSAGE:
        // type_name = field.type_name.substring (field.type_name.last_index_of (".") + 1);
        type_name = get_namespace (field.type_name);
        nullable = true;
        break;
    case FieldDescriptorProto.Type.TYPE_ENUM:
        // type_name = field.type_name.substring (field.type_name.last_index_of (".") + 1);
        type_name = get_namespace (field.type_name);
        break;
    default:
        type_name = "UNKNOWN_TYPE%d".printf (field.type);
        break;
    }

    if (!full)
        return type_name;

    if (is_proto3 && field.proto3_optional)
        nullable = true;

    switch (field.label)
    {
    case FieldDescriptorProto.Label.LABEL_REPEATED:
        if (needs_box)
            return "List<%s?>".printf (type_name);
        else
            return "List<%s>".printf (type_name);
    case FieldDescriptorProto.Label.LABEL_OPTIONAL:
        if (nullable)
            return "%s?".printf (type_name);
        else
            return type_name;
    default:
    case FieldDescriptorProto.Label.LABEL_REQUIRED:
        return type_name;    
    }
}

private static string get_field_name (FieldDescriptorProto field)
{
    string[] reserved_names = { "dynamic", "owned", "unowned", "weak" };

    string[] c_reserved_names =
    {
        "break",
        "case",
        "const",
        "continue",
        "default",
        "do",
        "else",
        "enum",
        "extern",
        "for",
        "if",
        "inline",
        "return",
        "sizeof",
        "static",
        "struct",
        "switch",
        "typeof",
        "void",
        "while"
    };

    foreach (var n in reserved_names)
        if (field.name == n)
            return "@%s".printf (field.name);
    foreach (var n in c_reserved_names)
        if (field.name == n)
            return "%s_".printf (field.name);

    return field.name;
}

private static string sanitize_identifier (string name)
{
    string[] reserved_names = { "dynamic", "owned", "unowned", "weak" };

    string[] c_reserved_names =
    {
        "break",
        "case",
        "const",
        "continue",
        "default",
        "do",
        "else",
        "enum",
        "extern",
        "for",
        "if",
        "inline",
        "return",
        "sizeof",
        "static",
        "struct",
        "switch",
        "typeof",
        "void",
        "while"
    };

    foreach (var n in reserved_names)
        if (name == n)
            return "@%s".printf (name);
    foreach (var n in c_reserved_names)
        if (name == n)
            return "%s_".printf (name);

    return name;
}

private static string camel_case (string name)
{
    var parts = name.split ("_");
    var sb = new GLib.StringBuilder ();
    foreach (var part in parts)
    {
        if (part.length == 0)
            continue;
        var head = part.substring (0, 1).up ();
        sb.append (head);
        if (part.length > 1)
            sb.append (part.substring (1));
    }
    if (sb.len == 0)
        return name;
    return sb.str;
}

private static string oneof_case_value_name (FieldDescriptorProto field)
{
    return "FIELD_%s".printf (field.name.up ());
}

private static bool is_packable (FieldDescriptorProto field)
{
    switch (field.type)
    {
    case FieldDescriptorProto.Type.TYPE_STRING:
    case FieldDescriptorProto.Type.TYPE_BYTES:
    case FieldDescriptorProto.Type.TYPE_MESSAGE:
    case FieldDescriptorProto.Type.TYPE_GROUP:
        return false;
    default:
        return true;
    }
}

private static bool is_packed (FieldDescriptorProto field, bool is_proto3)
{
    if (field.label != FieldDescriptorProto.Label.LABEL_REPEATED)
        return false;
    if (field.options != null && field.options.packed)
        return true;
    if (is_proto3 && is_packable (field))
        return true;
    return false;
}

private static bool is_nullable_field (FieldDescriptorProto field, bool is_proto3)
{
    return is_proto3 && field.proto3_optional && field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL;
}

private static string get_default_value (FieldDescriptorProto field, bool is_proto3 = false)
{
    if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        return "new %s ()".printf (get_type_name (field, true, is_proto3));
    if (is_proto3 && field.proto3_optional)
        return "null";

    switch (field.type)
    {
    case FieldDescriptorProto.Type.TYPE_DOUBLE:
        return "0d";
    case FieldDescriptorProto.Type.TYPE_FLOAT:
        return "0f";
    case FieldDescriptorProto.Type.TYPE_INT64:
    case FieldDescriptorProto.Type.TYPE_SINT64:
    case FieldDescriptorProto.Type.TYPE_UINT64:
    case FieldDescriptorProto.Type.TYPE_FIXED64:
    case FieldDescriptorProto.Type.TYPE_SFIXED64:
    case FieldDescriptorProto.Type.TYPE_INT32:
    case FieldDescriptorProto.Type.TYPE_SINT32:
    case FieldDescriptorProto.Type.TYPE_UINT32:
    case FieldDescriptorProto.Type.TYPE_FIXED32:
    case FieldDescriptorProto.Type.TYPE_SFIXED32:
        if (field.default_value != "")
            return field.default_value;
        else
            return "0";
    case FieldDescriptorProto.Type.TYPE_BOOL:
        if (field.default_value != "")
            return field.default_value;
        else
            return "false";
    case FieldDescriptorProto.Type.TYPE_STRING:
        if (field.default_value != "")
        {
            var value = field.default_value;
            value = value.replace ("\\", "\\\\");
            value = value.replace ("\"", "\\\"");
            return "\"%s\"".printf (value);
        }
        else
            return "\"\"";
    case FieldDescriptorProto.Type.TYPE_BYTES:
        return "null";
    case FieldDescriptorProto.Type.TYPE_MESSAGE:
        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL)
            return "null";
        else
            return "new %s ()".printf (get_type_name (field, true, is_proto3));
    case FieldDescriptorProto.Type.TYPE_ENUM:
        //var type_name = field.type_name.substring (field.type_name.last_index_of (".") + 1);
        var type_name = get_type_name (field, false, is_proto3);

        // stderr.printf ( "type_name.substring %s | get_type_name %s \n", type_name, get_type_name (field, false, is_proto3) );
        var enum_type = enums.lookup (field.type_name);
        if (enum_type == null && !field.type_name.has_prefix ("."))
            enum_type = enums.lookup ("." + field.type_name);
        if (field.default_value != "")
            return "%s.%s".printf (type_name, field.default_value);
        else if (enum_type != null && enum_type.value.length () > 0)
            return "%s.%s".printf (type_name, enum_type.value.nth_data (0).name);
        else
            return "0"; // FIXME
    default:
        return "UNKNOWN_TYPE%d".printf (field.type);
    }
}

private static string get_to_string_method (FieldDescriptorProto field, string field_name, string indent = "", bool is_proto3 = false)
{
    switch (field.type)
    {
    case FieldDescriptorProto.Type.TYPE_STRING:
        return "Protobuf.string_to_string (%s)".printf (field_name);
    case FieldDescriptorProto.Type.TYPE_BYTES:
        return "Protobuf.bytes_to_string (%s)".printf (field_name);
    case FieldDescriptorProto.Type.TYPE_MESSAGE:
        return "%s.to_string (indent + \"%s\")".printf (field_name, indent);
    case FieldDescriptorProto.Type.TYPE_ENUM:
        //var type_name = field.type_name.substring (field.type_name.last_index_of (".") + 1);
        var type_name = get_type_name (field, false, is_proto3);
        return "%s_to_string (%s)".printf (type_name, field_name);
    default:
        return "%s.to_string ()".printf (field_name);
    }
}
